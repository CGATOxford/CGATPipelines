"""
==============================
Pipeline somatic exome gatk4
==============================

Overview
========

This pipeline calls somatic variants from matched tumour and normal 
whole exome sequencing data using the GATK4 best practice pipelines.

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.ini` file.

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_@template@.py config

Input files
-----------

paired end fastqc files
bed file of exome enriched regions

file naming:
samples must be named samplename_X-control-lane1.fastq.1.gz and samplename_X-tumour-lane1.fastq.1.gz respectively for downstream compatibility
for control sample, X should be 1
for tumour samples, X should be 1,2,3

Requirements
------------

gatk4
picard
samtools
bwa


Pipeline output
===============

annotated VCF file
Tab-delimted file of filtered variants


Code
====

"""
from ruffus import *
import sys
import os
import gzip
import CGAT.Experiment as E
import CGATPipelines.Pipeline as P

# load options from the config file
PARAMS = P.getParameters(
    ["%s/pipeline.ini" % os.path.splitext(__file__)[0],
     "../pipeline.ini",
     "pipeline.ini"])


########## Read QC ########## 

@follows(mkdir("fastqc"))
@transform("*.fastq.gz",
           regex(r"(\S+).fastq.gz"),
           r"fastqc/\1_fastqc.log")
def run_fastqc(infile, outfile):
    '''Run fastqc on raw reads '''
    statement = '''fastqc -o fastqc --nogroup --extract %(infile)s >& %(outfile)s '''
    P.run()


@follows(mkdir("report"))
@merge(run_fastqc, "report/fastqc.html")
def fastqc_report(infiles, outfile):
    statement = '''LANG=en_GB.UTF-8 multiqc fastqc 
                    --filename report/fastqc &> %(outfile)s.log '''
    P.run()



@follows(mkdir("unmapped_bam"))
@follows(fastqc_report)
@transform("*.fastq.gz",
           regex(r"(.*)_R1_001.fastq.gz"),
           r"unmapped_bam/\1.ubam")
def FastQtoSam(infile, outfile):
    '''returns an unaligned bam file'''
    infile2 = infile.replace("_R1_001.fastq.gz", "_R2_001.fastq.gz")
    filename = P.snip(os.path.basename(infile),"_R1_001.fastq.gz").split("_")
    sm = filename[0]
    with gzip.open(infile, 'rb') as inf:
        line1 = str(inf.readline())
        fields = line1.split(":")
        rg = fields[2] + "_" + fields[3]
    # the command line statement we want to execute
    statement = '''picard -Xmx32G FastqToSam 
                    USE_JDK_DEFLATER=true
                    USE_JDK_INFLATER=true
                    F1=%(infile)s F2=%(infile2)s 
                    O=%(outfile)s 
                    SM=%(sm)s 
                    RG=%(rg)s 
                    PL=ILLUMINA
                    TMP_DIR=${TMPDIR}/${USER}
                    '''
    P.run()

########## Trimming ########## 

@follows(mkdir("trimmed"))
@transform(FastQtoSam,
           regex(r"unmapped_bam/(\S+).ubam"),
           r"trimmed/\1.trim.ubam")
def trim_reads(infile, outfile):
    '''mark adapters'''
    job_threads = int(PARAMS['trim_threads'])
    statement = '''picard MarkIlluminaAdapters
                    USE_JDK_DEFLATER=true
                    USE_JDK_INFLATER=true
                    I=%(infile)s
                    O=%(outfile)s
                    M=%(outfile)s.metrics.txt
                    TMP_DIR=${TMPDIR}/${USER}
                    ''' 
    P.run()

@follows(mkdir("rg_fastq"))
@transform(trim_reads,
           regex(r"trimmed/(.*).trim.ubam"),
           r"rg_fastq/\1.rg.fastq.1.gz")
def SamToFastQ(infile, outfile):
    '''returns a pair of fastq files'''
    outfile2 = outfile.replace(".fastq.1.gz", ".fastq.2.gz")
    # the command line statement we want to execute
    statement = '''picard -Xmx32G SamToFastq                     
                    USE_JDK_DEFLATER=true
                    USE_JDK_INFLATER=true
                    I=%(infile)s
                    FASTQ=%(outfile)s
                    SECOND_END_FASTQ=%(outfile2)s
                    TMP_DIR=${TMPDIR}/${USER}
                    '''
    P.run()


########## Mapping ########## 

@follows(mkdir("mapping"))
@transform(SamToFastQ,
           regex(r"rg_fastq/(.*).rg.fastq.1.gz"),
           r"mapping/\1.bam")
def bwamem(infile, outfile):
    '''maps the fastq files'''
    infile2 = infile.replace(".fastq.1.gz", ".fastq.2.gz")
    # the command line statement we want to execute
    job_threads = int(PARAMS['bwa_cores'])
    job_memory = '2G'
    outprefix = P.snip(outfile, ".bam")
    statement = '''bwa mem -t %(bwa_cores)s -M %(bwa_index)s 
                    %(infile)s  %(infile2)s
                    | samtools sort -o %(outfile)s -T %(outprefix)s - 
                    2> %(outfile)s.log'''
    P.run()

######## Mapping QC ######
    
@follows(mkdir("mapping_qc"))
@transform(bwamem,
           regex(r"mapping/(.*).bam"),
           r"mapping_qc/\1.txt")
def mapping_qc(infile, outfile):
    '''runs Picard alignment summary matrix'''
    # the command line statement we want to execute
    job_threads = 4
    job_memory = PARAMS["picard_memory"]
    basename = P.snip(outfile, "txt")
    statement = '''picard -Xmx%(job_memory)s CollectMultipleMetrics
                    USE_JDK_DEFLATER=true
                    USE_JDK_INFLATER=true
                    TMP_DIR=${TMPDIR}/${USER}
                    INPUT=%(infile)s
                    REFERENCE_SEQUENCE=%(bwa_index)s
                    ASSUME_SORTED=true
                    OUTPUT=%(basename)s
                    VALIDATION_STRINGENCY=SILENT
                    PROGRAM=CollectAlignmentSummaryMetrics
                    PROGRAM=CollectInsertSizeMetrics
                    PROGRAM=CollectGcBiasMetrics
                    >& %(outfile)s'''
    P.run()


@follows(mkdir("report"))
@merge(mapping_qc, "report/mapping_statistics.html")
def mapping_report(infiles, outfile):
    statement = '''LANG=en_GB.UTF-8 multiqc mapping_qc/
                        --filename report/mapping_statistics &> %(outfile)s.log'''
    P.run()
    
############################################################################### 

@follows(mkdir("merge_bam_alignment"))
@follows(mapping_report)
@transform(bwamem,
           regex(r"mapping/(.*).bam"),
           r"merge_bam_alignment/\1.mergali.bam")
def merge_bam_alignment(infile, outfile):
    '''merges the unmapped and mapped bam files'''
    infile2 = infile.replace("mapping", "unmapped_bam").replace(".bam", ".ubam")
    # the command line statement we want to execute
    job_memory = '64G'
    # export JAVA_TOOL_OPTIONS="-Djava.io.tmpdir=${TMPDIR}" &&
    statement = ''' picard -Xmx64G MergeBamAlignment 
                    USE_JDK_DEFLATER=true
                    USE_JDK_INFLATER=true
                    TMP_DIR=${TMPDIR}/${USER}
                    ALIGNED=%(infile)s 
                    UNMAPPED=%(infile2)s
                    O=%(outfile)s
                    R=%(bwa_index)s'''
    P.run()
    
@follows(mkdir("merge_sam")) 
@collate(merge_bam_alignment,
           regex(r"merge_bam_alignment/(.*)_(.*)_L00\d.mergali.bam"),
           r"merge_sam/\1.mergsam.bam")
def merge_sam(infiles, outfile):
    '''merges the files from different flow cell lanes into one'''
    #need to write code that will take multiple infiles and merge them
    job_memory = '32G'
    statement = '''picard -Xmx32G MergeSamFiles'''
    
    for e in infiles:
        statement = statement + ' I={}'.format(e)
    statement = statement + ' O={}'.format(outfile)
    # the command line statement we want to execute
            
    P.run()
 

@follows(mkdir("mark_duplicates"))
@transform(merge_sam,
           regex(r"merge_sam/(.*).mergsam.bam"),
           r"mark_duplicates/\1.md.bam")
def mark_duplicates(infile, outfile):
    '''marks duplicates'''
    outfile2 = outfile.replace(".md.bam", ".md.txt")
    # the command line statement we want to execute
    job_memory = '16G'
    statement = '''picard -Xmx16G MarkDuplicates
                    USE_JDK_DEFLATER=true
                    USE_JDK_INFLATER=true
                    TMP_DIR=${TMPDIR}/${USER}
                    I=%(infile)s
                    O=%(outfile)s 
                    M=%(outfile2)s
                    >& %(outfile)s.log'''        
    P.run()
    
@follows(mkdir("bqsr"))
@transform(mark_duplicates,
           regex(r"mark_duplicates/(.*).md.bam"),
           r"bqsr/\1.bqsr.table")
def bqsr(infile, outfile):
    '''creates a base score recalibration table'''
    # the command line statement we want to execute
    statement = ''' gatk BaseRecalibrator 
                    -I=%(infile)s
                    -R=%(bwa_index)s 
                    --known-sites %(dbsnp)s
                    -O=%(outfile)s
                    >& %(outfile)s.log'''
                    
    P.run()
    
    
@follows(mkdir("apply_bqsr"))
@follows(mark_duplicates)
@transform(bqsr,
           regex(r"bqsr/(.*).bqsr.table"),
                 r"apply_bqsr/\1.recalibrated.bam")
def apply_bqsr(infile, outfile):
    '''recalibrates the bam files'''
    # the command line statement we want to execute
    infile_bam = "mark_duplicates/" + P.snip(os.path.basename(infile), "bqsr.table") + "md.bam"
    
    statement = '''gatk ApplyBQSR 
                   -R=%(bwa_index)s
                   -I=%(infile_bam)s
                   --bqsr-recal-file %(infile)s 
                   -O=%(outfile)s
                   >& %(outfile)s.log''' 



    P.run()
    
#### Final Bam QC ######
    
@follows(mkdir("bqsr_qc"))
@transform(apply_bqsr,
           regex(r"apply_bqsr/(.*).recalibrated.bam"),
           r"bqsr_qc/\1.txt")
def bqsr_qc(infile, outfile):
    '''runs Picard alignment summary matrix'''
    # the command line statement we want to execute
    job_threads = 4
    job_memory = PARAMS["picard_memory"]
    basename = P.snip(outfile, "txt")
    statement = '''picard -Xmx%(job_memory)s CollectMultipleMetrics
                    USE_JDK_DEFLATER=true
                    USE_JDK_INFLATER=true
                    INPUT=%(infile)s
                    REFERENCE_SEQUENCE=%(bwa_index)s
                    ASSUME_SORTED=true
                    OUTPUT=%(basename)s
                    VALIDATION_STRINGENCY=SILENT
                    PROGRAM=CollectAlignmentSummaryMetrics
                    PROGRAM=CollectInsertSizeMetrics
                    PROGRAM=CollectGcBiasMetrics
                    >& %(outfile)s'''
    P.run()
    




#### CollectHsMetrics ######
    
@follows((mkdir("HsMetrics")))
@transform(apply_bqsr,
           regex(r"apply_bqsr/(.*).recalibrated.bam"),
           r"HsMetrics/\1_enrichment.txt")
def HsMetrics(infile, outfile):
    '''runs Picard hybrid selection summary metrics'''
    job_threads = 4
    job_memory = PARAMS["picard_memory"]
    target_intervals = PARAMS["picard_targets"]
    bait_intervals = PARAMS["picard_baits"]
    logfile = outfile.replace(".txt",".log")
    statement = '''picard -Xmx%(job_memory)s CollectHsMetrics
                    USE_JDK_DEFLATER=true
                    USE_JDK_INFLATER=true
                    TMP_DIR=${TMPDIR}/${USER}
                    INPUT=%(infile)s
                    REFERENCE_SEQUENCE=%(bwa_index)s
                    BAIT_INTERVALS=%(bait_intervals)s
                    TARGET_INTERVALS=%(target_intervals)s
                    OUTPUT= %(outfile)s 2> %(logfile)s'''
                    
    P.run()
    
    #### Final QC Report ######
    
@follows(mkdir("report"), HsMetrics)
@merge(bqsr_qc, "report/bqsr_statistics.html")
def bqsr_report(infiles, outfile):
    statement = '''LANG=en_GB.UTF-8 multiqc bqsr_qc/ HsMetrics/
                        --filename report/bqsr_statistics &> %(outfile)s.log'''
    P.run()
       
# =============================================================================
# @follows(mkdir("report"))
# @merge(HsMetrics, "report/hsmetrics_statistics.html")
# def HsMetrics_report(infiles, outfile):
#     statement = '''LANG=en_GB.UTF-8 multiqc HsMetrics/
#                         --filename report/hsmetrics_statistics &> %(outfile)s.log'''
#     P.run()
# =============================================================================
    
########### Variant calling  ##############################
  
# =============================================================================
# @follows(mkdir("mutect2"))
# @follows(bqsr_report)
# @transform(apply_bqsr,
#            regex(r"apply_bqsr/(.*)(-tumour).recalibrated.bam"),
#            r"mutect2/\1.pid")
# def patientID(infiles, outfile):
#     '''makes and empty file for patient ID'''
#     '''patient sample names should start with capital letters followed by numbers'''
#     '''might need to change it for different patient names'''
#     to_cluster = False
#     statement = '''touch %(outfile)s'''
#     P.run()
# =============================================================================
    
@follows(mkdir("mutect2"))
@transform(apply_bqsr, 
           regex( r"apply_bqsr/(\S+).recalibrated.bam",
                r"mutect2/\1.vcf")
def Mutect2(infile,outfile):
    samplename_tumour = P.snip(os.path.basename(infile),".recalibrated.bam")
    roi_intervals = PARAMS["mutect_intervals"]
    statement = '''gatk Mutect2 
                     -R=%(bwa_index)s
                     -I=%(infile_tumour)s
                     -tumor %(samplename_tumour)s
                     -L %(roi_intervals)s
                     %(mutects_options)s
                     -O=%(outfile)s'''   
                     
    P.run()
                     
@follows(mkdir("filter_mutect"))     
@transform(Mutect2, 
           regex(r"mutect2/(.*).vcf"),
                r"filter_mutect/\1.filtered.vcf")
def FilterMutect(infile,outfile):
    statement = '''gatk FilterMutectCalls
                    -V %(infile)s
                    -O %(outfile)s'''


    P.run()

################## Variant annotation ###################


################## Variant Filtering ####################


################## Variant export #######################

                     
         
def full(bqsr):
    pass


def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
